<!doctype html><html lang=en-us data-theme><head><meta charset=utf-8><meta name=HandheldFriendly content="True"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer-when-downgrade"><title>Flushing Promises in JavaScript - what it is and why you need it in UI tests - rickschubert.net blog</title><meta name=description content><link rel=icon type=image/x-icon href=https://rickschubert.net/blog/favicon.ico><link rel=apple-touch-icon-precomposed href=https://rickschubert.net/blog/favicon.png><link rel=stylesheet href=https://rickschubert.net/blog/css/style.min.ada65744b50c0c8e95fce70ffd6071f0d8830f31d28d4629c2a760b4cd8f97d1.css integrity><meta property="og:title" content="Flushing Promises in JavaScript - what it is and why you need it in UI tests"><meta property="og:description" content="&ldquo;This UI test is flaky, why does it sometimes fail?&rdquo; - &ldquo;Could it be because promises were not flushed?&rdquo; - &ldquo;Huuuuh?&rdquo; Chances are high that frontend developers will have had conversations like this. From my experience, many developers are still unaware of what flushing promises means and why we need it in automated tests of UI components such as with React or Angular. Let&rsquo;s shed some light on this.
All the example code can be found on this GitHub repository."><meta property="og:type" content="article"><meta property="og:url" content="https://rickschubert.net/blog/posts/flushing-promises/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-12-22T17:32:41+00:00"><meta property="article:modified_time" content="2020-12-22T17:32:41+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Flushing Promises in JavaScript - what it is and why you need it in UI tests"><meta name=twitter:description content="&ldquo;This UI test is flaky, why does it sometimes fail?&rdquo; - &ldquo;Could it be because promises were not flushed?&rdquo; - &ldquo;Huuuuh?&rdquo; Chances are high that frontend developers will have had conversations like this. From my experience, many developers are still unaware of what flushing promises means and why we need it in automated tests of UI components such as with React or Angular. Let&rsquo;s shed some light on this.
All the example code can be found on this GitHub repository."><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","G-252785X60E","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script></head><body><a class=skip-main href=#main>Skip to main content</a><div class=container><header class=common-header><div class=site-header><a class=site-title href=https://rickschubert.net/blog/>rickschubert.net blog</a>
<button class=theme-switcher></button>
<script>const moonSVG=`<svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"></path></svg>`,sunSVG=`<svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>`,STORAGE_KEY="user-color-scheme",defaultTheme="auto";let currentTheme,switchButton,autoDefinedScheme=window.matchMedia("(prefers-color-scheme: dark)");const autoChangeScheme=e=>{currentTheme=e.matches?"dark":"light",document.documentElement.setAttribute("data-theme",currentTheme),changeButtonText()};document.addEventListener("DOMContentLoaded",function(){switchButton=document.querySelector(".theme-switcher"),currentTheme=detectCurrentScheme(),currentTheme=="dark"&&document.documentElement.setAttribute("data-theme","dark"),currentTheme=="auto"&&(autoChangeScheme(autoDefinedScheme),autoDefinedScheme.addListener(autoChangeScheme)),changeButtonText(),switchButton.addEventListener("click",switchTheme,!1)});function detectCurrentScheme(){return localStorage.getItem(STORAGE_KEY)?localStorage.getItem(STORAGE_KEY):defaultTheme?defaultTheme:window.matchMedia?window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light":"light"}function changeButtonText(){switchButton.innerHTML=currentTheme=="dark"?moonSVG:sunSVG}function switchTheme(){currentTheme=="dark"?(localStorage.setItem(STORAGE_KEY,"light"),document.documentElement.setAttribute("data-theme","light"),currentTheme="light"):(localStorage.setItem(STORAGE_KEY,"dark"),document.documentElement.setAttribute("data-theme","dark"),currentTheme="dark"),changeButtonText()}</script></div></header><main id=main tabindex=-1><article class=post><header class=post-header><h1 class=post-title>Flushing Promises in JavaScript - what it is and why you need it in UI tests</h1></header><div class=content><p>&ldquo;This UI test is flaky, why does it sometimes fail?&rdquo; - &ldquo;Could it be because promises were not flushed?&rdquo; - &ldquo;Huuuuh?&rdquo; Chances are high that frontend developers will have had conversations like this. From my experience, many developers are still unaware of what flushing promises means and why we need it in automated tests of UI components such as with React or Angular. Let&rsquo;s shed some light on this.</p><div class=callout>All the example code can be found <a href=https://github.com/rickschubert/flushing-promises-explanation>on this GitHub repository</a>.</div><h2 id=why-do-i-need-to-flush-promises>Why do I need to flush promises?</h2><p>Consider the following case: I created a new UI component. On starting, it displays the text &ldquo;Empty&rdquo;. When the component renders, it starts a network request to a server. The server takes 1 second to return a response. Once the component receives the response, it replaces the text &ldquo;Empty&rdquo; with the response it received.</p><details><summary>Expand to see a demo GIF of the component:</summary><figure><img src=https://rickschubert.net/blog/images/flushing_promises_component_demo.gif><figcaption><h4>A demo of our dummy component</h4></figcaption></figure></details><p>The code of this dummy component:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#a6e22e>React</span> <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#34;react&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>makeNetworkRequest</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>response</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>fetch</span>(<span style=color:#e6db74>&#34;http://localhost:3001/what-day-is-it&#34;</span>)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>data</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>response</span>.<span style=color:#a6e22e>json</span>()
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>JSON</span>.<span style=color:#a6e22e>stringify</span>(<span style=color:#a6e22e>data</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>App</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>React</span>.<span style=color:#a6e22e>Component</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>constructor</span>(<span style=color:#a6e22e>props</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>super</span>(<span style=color:#a6e22e>props</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>state</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>webResponse</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;Empty&#34;</span>,
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>async</span> <span style=color:#a6e22e>componentDidMount</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>webResponse</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>makeNetworkRequest</span>()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>setState</span>({<span style=color:#a6e22e>webResponse</span>})
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>render</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> (
</span></span><span style=display:flex><span>      &lt;<span style=color:#f92672>div</span> <span style=color:#a6e22e>className</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;App&#34;</span>&gt;
</span></span><span style=display:flex><span>        &lt;<span style=color:#f92672>div</span> <span style=color:#a6e22e>className</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;response&#34;</span>&gt;{<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>state</span>.<span style=color:#a6e22e>webResponse</span>}&lt;/<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>      &lt;/<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>default</span> <span style=color:#a6e22e>App</span>
</span></span></code></pre></div><p>This component works, fantastic! So let&rsquo;s write some automated tests for this.</p><p>First, let&rsquo;s test our network request function in isolation. We will use <a href=https://github.com/nock/nock>the npm module nock</a> to mock the network request that would normally be made. This allows us to run the tests without our server. It will essentially fake the network request and have it always return a fake response, the JSON string <code>{"A": "mocked response"}</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#a6e22e>App</span>, {<span style=color:#a6e22e>makeNetworkRequest</span>} <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#34;./App&#34;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#a6e22e>nock</span> <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#34;nock&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>mockedWebResponse</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>JSON</span>.<span style=color:#a6e22e>stringify</span>(<span style=color:#e6db74>&#39;{&#34;A&#34;: &#34;mocked response&#34;}&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>setUpMock</span>() {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>nock</span>(<span style=color:#e6db74>/.*/</span>)
</span></span><span style=display:flex><span>    .<span style=color:#a6e22e>persist</span>()
</span></span><span style=display:flex><span>    .<span style=color:#a6e22e>defaultReplyHeaders</span>({
</span></span><span style=display:flex><span>      <span style=color:#e6db74>&#34;access-control-allow-origin&#34;</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;*&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:#e6db74>&#34;access-control-allow-credentials&#34;</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;true&#34;</span>,
</span></span><span style=display:flex><span>    })
</span></span><span style=display:flex><span>    .<span style=color:#a6e22e>get</span>(<span style=color:#e6db74>/what-day-is-it/</span>)
</span></span><span style=display:flex><span>    .<span style=color:#a6e22e>reply</span>(<span style=color:#ae81ff>200</span>, <span style=color:#a6e22e>mockedWebResponse</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>it</span>(<span style=color:#e6db74>&#34;Testing our network request&#34;</span>, <span style=color:#66d9ef>async</span> () =&gt; {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>setUpMock</span>()
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>result</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>makeNetworkRequest</span>()
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>expect</span>(<span style=color:#a6e22e>result</span>).<span style=color:#a6e22e>toEqual</span>(<span style=color:#a6e22e>mockedWebResponse</span>)
</span></span><span style=display:flex><span>})
</span></span></code></pre></div><p>This test passes, amazing. Take note that <code>makeNetworkRequest</code> is an asynchronous function. Since we are using the <code>async</code> and <code>await</code> keywords, nodejs will hold up with the subsequent I/O executions and only populate the <code>result</code> variable with a value once <code>makeNetworkRequest</code> finishes.</p><div class=callout>An I/O execution is any standard task which doesn't perform asynchronously, i.e. adding up 2 + 2.</div><p>Let&rsquo;s move on to testing our component. We will render the component using the <a href=https://testing-library.com/docs/react-testing-library/intro/>Testing Library npm module</a> and then check whether the text shows our fixed response:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>import</span> {<span style=color:#a6e22e>render</span>} <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#34;@testing-library/react&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>it</span>(<span style=color:#e6db74>&#34;Test if component renders web response&#34;</span>, () =&gt; {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>component</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>render</span>(<span style=color:#f92672>&lt;</span><span style=color:#a6e22e>App</span> <span style=color:#f92672>/&gt;</span>)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>response</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>component</span>.<span style=color:#a6e22e>container</span>.<span style=color:#a6e22e>querySelector</span>(<span style=color:#e6db74>&#34;.response&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>expect</span>(<span style=color:#a6e22e>response</span>.<span style=color:#a6e22e>textContent</span>).<span style=color:#a6e22e>toEqual</span>(<span style=color:#a6e22e>mockedWebResponse</span>)
</span></span><span style=display:flex><span>})
</span></span></code></pre></div><p>But this test is failing. Why? <strong>Because no promises have been flushed</strong>. Alternatively, because nodejs exited too early. What jest does here is executing the function inside the <code>it</code> block which includes I/O operations only. But the update of the component where the text changes from &ldquo;Empty&rdquo; to our mocked response is not synchronous; this update happens in fact asynchronously because of our network request but also because of how React works internally. But since the test is not using any <code>await</code> keyword, nodejs exits as soon as possible. And this is the major problem with UI tests: <strong>Components are <em>observables</em> which don&rsquo;t return promises or values. Therefore, we cannot add <code>await</code> keywords anywhere at will.</strong></p><p>And this is why we need to flush promises. Let us first speak about how we could get the test to pass and we will then <a href=#how>discuss why it works</a>.</p><p>We can flush promises with the following function:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>flushPromises</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> Promise(<span style=color:#a6e22e>setImmediate</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Since it returns a promise, it needs to be called using <code>await</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#a6e22e>it</span>(<span style=color:#e6db74>&#34;Test if component renders web response&#34;</span>, <span style=color:#66d9ef>async</span> () =&gt; {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>component</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>render</span>(<span style=color:#f92672>&lt;</span><span style=color:#a6e22e>App</span> <span style=color:#f92672>/&gt;</span>)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>response</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>component</span>.<span style=color:#a6e22e>container</span>.<span style=color:#a6e22e>querySelector</span>(<span style=color:#e6db74>&#34;.response&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>index</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>index</span> <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>200</span>; <span style=color:#a6e22e>index</span><span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>flushPromises</span>()
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>expect</span>(<span style=color:#a6e22e>response</span>.<span style=color:#a6e22e>textContent</span>).<span style=color:#a6e22e>toEqual</span>(<span style=color:#a6e22e>mockedWebResponse</span>)
</span></span><span style=display:flex><span>})
</span></span></code></pre></div><p>And there you go, the test passes now! Alternatively, we could also use the <code>waitFor</code> helper exposed by the Testing Library. <a href=https://github.com/testing-library/dom-testing-library/blob/e3fc7f3a0d29921a5821d361394446968d77eca5/src/wait-for.js#L89>A deep-dive into the source code</a> shows that it is essentially just a wrapper around our current solution which also uses <code>setImmediate</code> - but the <code>waitFor</code> helper doesn&rsquo;t flush for a random 200 times but only as often as actually needed. This speeds up our test slightly.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>import</span> {<span style=color:#a6e22e>render</span>, <span style=color:#a6e22e>waitFor</span>} <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#34;@testing-library/react&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>it</span>(<span style=color:#e6db74>&#34;Test if component renders web response&#34;</span>, <span style=color:#66d9ef>async</span> () =&gt; {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>component</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>render</span>(<span style=color:#f92672>&lt;</span><span style=color:#a6e22e>App</span> <span style=color:#f92672>/&gt;</span>)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>response</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>component</span>.<span style=color:#a6e22e>container</span>.<span style=color:#a6e22e>querySelector</span>(<span style=color:#e6db74>&#34;.response&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>waitFor</span>(() =&gt; <span style=color:#a6e22e>expect</span>(<span style=color:#a6e22e>response</span>.<span style=color:#a6e22e>textContent</span>).<span style=color:#a6e22e>toEqual</span>(<span style=color:#a6e22e>mockedWebResponse</span>))
</span></span><span style=display:flex><span>})
</span></span></code></pre></div><h2 id=a-namehowahow-does-flushing-promises-work><a name=how></a>How does flushing promises work</h2><p>As you saw above, both solutions involved the function <code>setImmediate</code>. This function is special. In fact, the MDN Web Docs mention <a href=https://developer.mozilla.org/en-US/docs/Web/API/Window/setImmediate>that it should not be used in production websites</a>. But since we only deal here with nodejs and tests, this doesn&rsquo;t matter to us.</p><p>In order to know more about how <code>setImmediate</code> works, we need to learn <a href=https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/>what the JavaScript event loop is</a>. I will try my best to sum it up and paraphrase: JavaScript is a <em>non-blocking</em> programming language. This means that if I would make 10 network requests each taking 1 second then my program would not take 10 seconds but still only 1 second. This is achieved via the event loop which is essentially a task queue. JavaScript then takes the tasks from the task queue and executes them concurrently.</p><p>Imagine you are in school and your teacher gives you homework - you will not complete all of these tasks right the instance the teacher asked you to do so; instead, you will write down these tasks in your notebook and you will execute these tasks once it&rsquo;s a convenient time to do so.</p><p>Sticking to the homework example, let&rsquo;s pretend your teacher gave you 100 tasks of homework. But there is only so much you can do in one day, you only have time for 10 exercises per day. This is your &ldquo;call stack size&rdquo;. The nodejs event loop looks at all scheduled tasks and tries to put as many as possible onto the call stack so that they can be executed.</p><p>But here is where the function <code>setImmediate</code> comes in. If the teacher would have given 100 tasks for the next week, nodejs would try to prioritise the tasks which the teacher gave the longest time ago in order to catch up. But functions which are scheduled using <code>setImmediate</code> are special - these functions are additional tasks. This means that if your teacher gave you 100 tasks <strong>and</strong> 5 tasks scheduled using <code>setImmediate</code>, nodejs will first do the 10 tasks it can do per day and then <strong>additionally</strong> also do all of the tasks queued up using <code>setImmediate</code>. In essence, <code>setImmediate</code> functions are extra tasks which take higher priority.</p><p>How does this translate onto our <code>flushPromises</code> function? The above way of writing was implicit, so let&rsquo;s pick it apart and write it explicitly:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>flushPromises</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> Promise((<span style=color:#a6e22e>resolve</span>, <span style=color:#a6e22e>reject</span>) =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>setImmediate</span>(() =&gt; {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>resolve</span>()
</span></span><span style=display:flex><span>    })
</span></span><span style=display:flex><span>  })
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>What happens is that an asynchronous event (all functions returning promises are async functions) is being scheduled which contains a <code>setImmediate</code> call. As we have learnt, <code>setImmediate</code> is only called in the event loop <strong>after</strong> tasks from the call stack have been executed. <strong>Therefore the event loop is forced to execute tasks of the call stack first before it can call setImmediate</strong>. Our <code>setImmediate</code> function is basically sandwiched into all of the other queued up tasks. Since we are returning a promise, we have again something to wait for using the <code>await</code> keyword.</p><p>In essence, because <code>setImmediate</code> always happens <em>after</em> the execution of tasks on the event loop, &ldquo;flushing promises&rdquo; is about <strong>forcing</strong> the event loop to execute some queued up tasks. But since the call stack is only limited (remember that we can only do 10 pieces of homework per day), we need to call it multiple times in order to force multiple cycles through the event loop.</p><hr><p>And that&rsquo;s flushing promises for you! I hope that this article both helped you understand the problem and also how to solve it.</p></div><div class=post-info><div class=post-date>22 December 2020</div><div class=post-taxonomies><ul class=post-tags><li><a href=https://rickschubert.net/blog/tags/programming>#programming</a></li></ul></div></div></article><div class="pagination post-pagination"><div class="left pagination-item"><a href=https://rickschubert.net/blog/posts/volunteering-with-tech-skills-golang-music-library-reader/>Volunteering With My Programming Skills For A Non-Commercial Radio Station</a></div><div class="right pagination-item disabled"></div></div></main><footer class=common-footer><a class=rss href=https://rickschubert.net/blog/index.xml><img src=https://rickschubert.net/blog/images/rss.svg> Subscribe to RSS feed</a><nav><a href=https://rickschubert.net/blog/posts/ title=Archive>Archive</a></nav><div class=common-footer-bottom><div class=copyright><p>© Rick Schubert, 2022<br></p></div></div></footer></div></body></html>